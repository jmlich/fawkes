
/***************************************************************************
 *  NavGraphGeneratorInterface.h - Fawkes BlackBoard Interface - NavGraphGeneratorInterface
 *
 *  Templated created:   Thu Oct 12 10:49:19 2006
 *  Copyright  2015  Tim Niemueller
 *
 ****************************************************************************/

/*  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version. A runtime exception applies to
 *  this software (see LICENSE.GPL_WRE file mentioned below for details).
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
 */

#ifndef __INTERFACES_NAVGRAPHGENERATORINTERFACE_H_
#define __INTERFACES_NAVGRAPHGENERATORINTERFACE_H_

#include <interface/interface.h>
#include <interface/message.h>
#include <interface/field_iterator.h>

namespace fawkes {

class NavGraphGeneratorInterface : public Interface
{
 /// @cond INTERNALS
 INTERFACE_MGMT_FRIENDS(NavGraphGeneratorInterface)
 /// @endcond
 public:
  /* constants */

  /** Drive modes enum */
  typedef enum {
    CLOSEST_NODE /**< 
       Connect point to the node on the graph closest to the given
       point.
      */,
    CLOSEST_EDGE /**< 
       Connect point to the edge in which segment it lies, i.e. search
       for an edge where we can find a perpendicular line going
       through the given point and any point on the edge's line
       segment. If no such segment is found, the point cannot be
       added.
      */,
    CLOSEST_EDGE_OR_NODE /**< 
       First try the CLOSEST_EDGE method. If that yields no result,
       use the CLOSEST_NODE method as a fallback.
      */
  } ConnectionMode;
  const char * tostring_ConnectionMode(ConnectionMode value) const;

 private:
#pragma pack(push,4)
  /** Internal data storage, do NOT modify! */
  typedef struct {
    int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
    int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    uint32_t flags; /**< Bit-wise combination of
    FLAG_* constants denoting navigator component features. */
  } NavGraphGeneratorInterface_data_t;
#pragma pack(pop)

  NavGraphGeneratorInterface_data_t *data;

 public:
  /* messages */
  class ClearMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } ClearMessage_data_t;
#pragma pack(pop)

    ClearMessage_data_t *data;

   public:
    ClearMessage();
    ~ClearMessage();

    ClearMessage(const ClearMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class SetBoundingBoxMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float p1_x; /**< X coordinate of bbox start point in global frame. */
      float p1_y; /**< Y coordinate of bbox start point in global frame. */
      float p2_x; /**< X coordinate of bbox end point in global frame. */
      float p2_y; /**< Y coordinate of bbox end point in global frame. */
    } SetBoundingBoxMessage_data_t;
#pragma pack(pop)

    SetBoundingBoxMessage_data_t *data;

   public:
    SetBoundingBoxMessage(const float ini_p1_x, const float ini_p1_y, const float ini_p2_x, const float ini_p2_y);
    SetBoundingBoxMessage();
    ~SetBoundingBoxMessage();

    SetBoundingBoxMessage(const SetBoundingBoxMessage *m);
    /* Methods */
    float p1_x() const;
    void set_p1_x(const float new_p1_x);
    size_t maxlenof_p1_x() const;
    float p1_y() const;
    void set_p1_y(const float new_p1_y);
    size_t maxlenof_p1_y() const;
    float p2_x() const;
    void set_p2_x(const float new_p2_x);
    size_t maxlenof_p2_x() const;
    float p2_y() const;
    void set_p2_y(const float new_p2_y);
    size_t maxlenof_p2_y() const;
    virtual Message * clone() const;
  };

  class AddObstacleMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      char id[64]; /**< 
      ID of the obstacle. Can later be used to remove it again.
     */
      float x; /**< X coordinate of obstacle in global frame. */
      float y; /**< Y coordinate of obstacle in global frame. */
    } AddObstacleMessage_data_t;
#pragma pack(pop)

    AddObstacleMessage_data_t *data;

   public:
    AddObstacleMessage(const char * ini_id, const float ini_x, const float ini_y);
    AddObstacleMessage();
    ~AddObstacleMessage();

    AddObstacleMessage(const AddObstacleMessage *m);
    /* Methods */
    char * id() const;
    void set_id(const char * new_id);
    size_t maxlenof_id() const;
    float x() const;
    void set_x(const float new_x);
    size_t maxlenof_x() const;
    float y() const;
    void set_y(const float new_y);
    size_t maxlenof_y() const;
    virtual Message * clone() const;
  };

  class RemoveObstacleMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      char id[64]; /**< 
      ID of the obstacle to remove.
     */
    } RemoveObstacleMessage_data_t;
#pragma pack(pop)

    RemoveObstacleMessage_data_t *data;

   public:
    RemoveObstacleMessage(const char * ini_id);
    RemoveObstacleMessage();
    ~RemoveObstacleMessage();

    RemoveObstacleMessage(const RemoveObstacleMessage *m);
    /* Methods */
    char * id() const;
    void set_id(const char * new_id);
    size_t maxlenof_id() const;
    virtual Message * clone() const;
  };

  class AddPointOfInterestMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      char id[64]; /**< 
      ID of the obstacle. Can later be used to remove it again.
     */
      float x; /**< X coordinate of obstacle in global frame. */
      float y; /**< Y coordinate of obstacle in global frame. */
      int32_t mode; /**< 
      The connection mode to use to connect the POI with the graph.
     */
    } AddPointOfInterestMessage_data_t;
#pragma pack(pop)

    AddPointOfInterestMessage_data_t *data;

   public:
    AddPointOfInterestMessage(const char * ini_id, const float ini_x, const float ini_y, const ConnectionMode ini_mode);
    AddPointOfInterestMessage();
    ~AddPointOfInterestMessage();

    AddPointOfInterestMessage(const AddPointOfInterestMessage *m);
    /* Methods */
    char * id() const;
    void set_id(const char * new_id);
    size_t maxlenof_id() const;
    float x() const;
    void set_x(const float new_x);
    size_t maxlenof_x() const;
    float y() const;
    void set_y(const float new_y);
    size_t maxlenof_y() const;
    ConnectionMode mode() const;
    void set_mode(const ConnectionMode new_mode);
    size_t maxlenof_mode() const;
    virtual Message * clone() const;
  };

  class SetPointOfInterestPropertyMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      char id[64]; /**< 
      ID of the point of interest.
     */
      char property_name[64]; /**< Name of the property to set. */
      char property_value[1024]; /**< Value of the property
    to set. */
    } SetPointOfInterestPropertyMessage_data_t;
#pragma pack(pop)

    SetPointOfInterestPropertyMessage_data_t *data;

   public:
    SetPointOfInterestPropertyMessage(const char * ini_id, const char * ini_property_name, const char * ini_property_value);
    SetPointOfInterestPropertyMessage();
    ~SetPointOfInterestPropertyMessage();

    SetPointOfInterestPropertyMessage(const SetPointOfInterestPropertyMessage *m);
    /* Methods */
    char * id() const;
    void set_id(const char * new_id);
    size_t maxlenof_id() const;
    char * property_name() const;
    void set_property_name(const char * new_property_name);
    size_t maxlenof_property_name() const;
    char * property_value() const;
    void set_property_value(const char * new_property_value);
    size_t maxlenof_property_value() const;
    virtual Message * clone() const;
  };

  class RemovePointOfInterestMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      char id[64]; /**< 
      ID of the obstacle to remove.
     */
    } RemovePointOfInterestMessage_data_t;
#pragma pack(pop)

    RemovePointOfInterestMessage_data_t *data;

   public:
    RemovePointOfInterestMessage(const char * ini_id);
    RemovePointOfInterestMessage();
    ~RemovePointOfInterestMessage();

    RemovePointOfInterestMessage(const RemovePointOfInterestMessage *m);
    /* Methods */
    char * id() const;
    void set_id(const char * new_id);
    size_t maxlenof_id() const;
    virtual Message * clone() const;
  };

  class ComputeMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } ComputeMessage_data_t;
#pragma pack(pop)

    ComputeMessage_data_t *data;

   public:
    ComputeMessage();
    ~ComputeMessage();

    ComputeMessage(const ComputeMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  virtual bool message_valid(const Message *message) const;
 private:
  NavGraphGeneratorInterface();
  ~NavGraphGeneratorInterface();

 public:
  /* Methods */
  uint32_t flags() const;
  void set_flags(const uint32_t new_flags);
  size_t maxlenof_flags() const;
  virtual Message * create_message(const char *type) const;

  virtual void copy_values(const Interface *other);
  virtual const char * enum_tostring(const char *enumtype, int val) const;

};

} // end namespace fawkes

#endif
